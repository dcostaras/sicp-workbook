#+title: SICP Workbook
#+setupfile: ./setup/setup-file.org

* Ch. 1.1.6
** Ex. 1.1

#+begin_quote
Below is a sequence of expressions.  What is the result printed by the interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented.
#+end_quote

#+begin_src scheme
10
;; => 10

(+ 5 3 4)
;; => 12

(- 9 1)
;; => 8

(/ 6 2)
;; => 3

(+ (* 2 4) (- 4 6))
;; => 6

(define a 3)
;; => a

(define b (+ a 1))
;; => b

(+ a b (* a b))
;; => 19

(= a b)
;; => #f

(if (and (> b a) (< b (* a b)))
    b
    a)
;; => 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
;; => 16

(+ 2 (if (> b a) b a))
;; => 6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
;; => 16
#+end_src

** Ex. 1.2

#+begin_quote
Translate the following expression into prefix form: $\frac{5 + 4 + (2 - (3 - (6 + 4/5)))}{3(6 - 2)(2 - 7)}$
#+end_quote

#+begin_src scheme :exports both
(define prefix-expression
  (/ (+ 5 4 (- 2 (- 3 (+ 6 4/5))))
          (* 3 (- 6 2) (- 2 7))))

(exact->inexact prefix-expression)
#+end_src

#+RESULTS:
: -0.24666666666666667

Checked via calculator
$\frac{5 + 4 + (2 - (3 - (6 + 4/5)))}{3(6 - 2)(2 - 7)} \approx -0.24666666666$

** Ex. 1.3

#+begin_quote
Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.
#+end_quote

#+begin_src scheme :exports both
(define (square x)
  (* x x))

(define (sum-of-squares-of-larger-two x y z)
  (cond ((> x y) (+ (square x) (square z)))
        ((> y z) (+ (square y) (square x)))
        ((> z x) (+ (square z) (square y)))
        (else (* 2 (square x)))))

(and
 (= 13 (sum-of-squares-of-larger-two 2 3 1))
 (= 13 (sum-of-squares-of-larger-two 2 3 2))
 (= 13 (sum-of-squares-of-larger-two 2 1 3))
 (= 13 (sum-of-squares-of-larger-two 1 2 3))

 (= 2 (sum-of-squares-of-larger-two 1 1 1))
 (= 0 (sum-of-squares-of-larger-two 0 0 0)))
#+end_src

#+RESULTS:
: #t

** Ex. 1.4

#+begin_quote
Observe that our model of evaluation allows for combinations whose operators are compound expressions.  Use this observation to describe the behavior of the following procedure:
#+end_quote

#+begin_src scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+end_src

The function defined is $a + abs(b)$.

In the Scheme definition, the top operator of the body is an ~if~ expression that evaluates to either the ~+~ or ~-~ function depending on the sign of ~b~.

If ~b~ is positive then ~(abs b)~ of ~b~ will be ~b~ and consequently we just need to add that to ~a~ as $a + abs(b) = a + b$ when $b > 0$. We do that by returning ~+~ from the ~if~ expression which is then the operator of the parent expression with ~a~ and ~b~ as operands. On the other hand if ~b~ is negative then ~(abs b)~ will be ~(- b)~ and so we return ~-~ from the inner expression as the operator of the parent expression which is equivalent to the functions definition $a + abs(b)$ or ~(+ a (abs b))~.

The key idea is that the operator of combinations can itself be a compound expression.


** Ex. 1.5

* Square roots by Newton's method

#+begin_src scheme :results none
(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (square x)
  (* x x))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
#+end_src

#+begin_src scheme
(sqrt 1000)
#+end_src

#+RESULTS:
: 31.622782450701045
